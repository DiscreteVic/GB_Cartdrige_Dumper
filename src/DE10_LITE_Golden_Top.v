// ============================================================================
//   Ver  :| Author					:| Mod. Date :| Changes Made:
//   V1.1 :| Alexandra Du			:| 06/01/2016:| Added Verilog file
// ============================================================================


//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

`define ENABLE_ADC_CLOCK
`define ENABLE_CLOCK1
//`define ENABLE_CLOCK2
//`define ENABLE_SDRAM
`define ENABLE_HEX0
`define ENABLE_HEX1
`define ENABLE_HEX2
`define ENABLE_HEX3
`define ENABLE_HEX4
`define ENABLE_HEX5
`define ENABLE_KEY/*
`define ENABLE_LED
`define ENABLE_SW
`define ENABLE_VGA
`define ENABLE_ACCELEROMETER*/
`define ENABLE_ARDUINO
`define ENABLE_GPIO

module DE10_LITE_Golden_Top(

	//////////// ADC CLOCK: 3.3-V LVTTL //////////
`ifdef ENABLE_ADC_CLOCK
	input 		          		ADC_CLK_10,
`endif
	//////////// CLOCK 1: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK1
	input 		          		MAX10_CLK1_50,
`endif
	//////////// CLOCK 2: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK2
	input 		          		MAX10_CLK2_50,
`endif

	//////////// SDRAM: 3.3-V LVTTL //////////
`ifdef ENABLE_SDRAM
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,
`endif

	//////////// SEG7: 3.3-V LVTTL //////////
`ifdef ENABLE_HEX0
	output		     [7:0]		HEX0,
`endif
`ifdef ENABLE_HEX1
	output		     [7:0]		HEX1,
`endif
`ifdef ENABLE_HEX2
	output		     [7:0]		HEX2,
`endif
`ifdef ENABLE_HEX3
	output		     [7:0]		HEX3,
`endif
`ifdef ENABLE_HEX4
	output		     [7:0]		HEX4,
`endif
`ifdef ENABLE_HEX5
	output		     [7:0]		HEX5,
`endif

	//////////// KEY: 3.3 V SCHMITT TRIGGER //////////
`ifdef ENABLE_KEY
	input 		     [1:0]		KEY,
`endif

	//////////// LED: 3.3-V LVTTL //////////
`ifdef ENABLE_LED
	output		     [9:0]		LEDR,
`endif

	//////////// SW: 3.3-V LVTTL //////////
`ifdef ENABLE_SW
	input 		     [9:0]		SW,
`endif

	//////////// VGA: 3.3-V LVTTL //////////
`ifdef ENABLE_VGA
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,
`endif

	//////////// Accelerometer: 3.3-V LVTTL //////////
`ifdef ENABLE_ACCELEROMETER
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,
`endif

	//////////// Arduino: 3.3-V LVTTL //////////
`ifdef ENABLE_ARDUINO
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,
`endif

	//////////// GPIO, GPIO connect to GPIO Default: 3.3-V LVTTL //////////
`ifdef ENABLE_GPIO
	inout 		    [35:0]		GPIO
`endif
);

parameter DUMPS_TO_DO = 3;
parameter INTERNAL_MEMORY_SIZE = 1;
parameter OPENMSG_SIZE = 3;
parameter ENDMSG_SIZE = 3;

//=======================================================
//  REG/WIRE declarations
//=======================================================

reg gba_cart_RD;
reg gba_cart_CS;
reg [15:0]gba_cart_lowAdd;
reg [7:0]gba_cart_upAdd;
reg [23:0]gba_cart_Add;
wire [15:0]gba_cart_romData;
wire [15:0]romData;
reg gba_cart_CS2;
wire gba_cart_REQ;


wire clkSlow;
wire clkFast;
reg [3:0]digA;
reg [3:0]digB;
reg [7:0]step;
reg [7:0]nextStep;
reg budDir;


wire tx;
reg [7:0]tx_data;
wire portAvailable;

reg newDump;
reg transmit;
reg send;

integer memIdx;
integer memIdxB;
integer nDumps;
reg [7:0]memDumped[0:INTERNAL_MEMORY_SIZE];
reg [7:0]openMsg[0:OPENMSG_SIZE];
reg [7:0]endMsg[0:ENDMSG_SIZE];





assign ARDUINO_IO[12] = tx;

assign GPIO[35] = gba_cart_RD;
assign GPIO[34] = gba_cart_CS;
assign GPIO[23:16] = gba_cart_upAdd;

//assign gba_cart_romData = romData;


initial begin
	openMsg[0] = 8'H00; //----- DEAD WORD
	openMsg[1] = 8'H3C; 
	openMsg[2] = 8'H53;
	/*openMsg[3] = 8'H54;
	openMsg[4] = 8'H41;
	openMsg[5] = 8'H52;
	openMsg[6] = 8'H54;
	openMsg[7] = 8'H49;
	openMsg[8] = 8'H4E;
	openMsg[9] = 8'H47;
	openMsg[10] = 8'H20;
	openMsg[11] = 8'H54;
	openMsg[12] = 8'H52;
	openMsg[13] = 8'H41;
	openMsg[14] = 8'H4E;
	openMsg[15] = 8'H53;
	openMsg[16] = 8'H4D;
	openMsg[17] = 8'H49;
	openMsg[18] = 8'H53;
	openMsg[19] = 8'H49;
	openMsg[20] = 8'H4F;
	openMsg[21] = 8'H4E;*/
	openMsg[3] = 8'H3E;

	endMsg[0] = 8'H00; //----- DEAD WORD
	endMsg[1] = 8'H3C; 
	endMsg[2] = 8'H45;
	/*endMsg[3] = 8'H4E;
	endMsg[4] = 8'H44;
	endMsg[5] = 8'H49;
	endMsg[6] = 8'H4E;
	endMsg[7] = 8'H47;
	endMsg[8] = 8'H20;
	endMsg[9] = 8'H54;
	endMsg[10] = 8'H52;
	endMsg[11] = 8'H41;
	endMsg[12] = 8'H4E;
	endMsg[13] = 8'H53;
	endMsg[14] = 8'H4D;
	endMsg[15] = 8'H49;
	endMsg[16] = 8'H53;
	endMsg[17] = 8'H49;
	endMsg[18] = 8'H4F;
	endMsg[19] = 8'H4E;*/
	endMsg[3] = 8'H3E;
end



//=======================================================
//  Structural coding
//=======================================================

Prescaler #(.N(6)) pres(.clk_in(MAX10_CLK1_50), .clk_out(clkSlow));

Prescaler #(.N(4)) presUART(.clk_in(MAX10_CLK1_50), .clk_out(clkFast)); //3Mbaud

SevSegController ssc0(.dig(nDumps[3:0]),.dot(nDumps[24]),.leds(HEX0));
SevSegController ssc1(.dig(nDumps[7:4]),.dot(0),.leds(HEX1));
SevSegController ssc4(.dig(nDumps[11:8]),.dot(0),.leds(HEX2));
SevSegController ssc5(.dig(nDumps[15:12]),.dot(0),.leds(HEX3));
SevSegController ssc2(.dig(nDumps[19:16]),.dot(0),.leds(HEX4));
SevSegController ssc3(.dig(nDumps[23:20]),.dot(),.leds(HEX5));

bidirec bdBus(budDir,clkFast, gba_cart_lowAdd, gba_cart_romData, GPIO[15:0]);

UART uart0(.clk(clkFast),  .tx(tx),  .txData(tx_data),  .portAvailable(portAvailable),  .send(send));

initial gba_cart_RD = 1'b0;
initial gba_cart_CS = 1'b0;
initial gba_cart_lowAdd = 16'H0000;
initial gba_cart_upAdd = 8'H00;
initial budDir = 1'b1;

initial step = 8'H00;
initial nextStep = 8'H00;
initial gba_cart_Add = 24'H0000000;

initial memIdx = 0;
initial memIdxB = 0;
initial send = 0;
initial transmit = 0;
initial newDump = 0;
initial nDumps = 24'H0000000;

/*
always @(posedge(KEY[0])) begin
	if(step!=8'H06)step <= step + 1;
	if(step==8'H06)step <= 8'H00;
end
*/
always @(posedge(clkSlow)) begin

	case (step)
		8'H00: // ----- NON SEQUENTIAL
			begin
				gba_cart_RD <= 1'b1;
				step <= 8'H01;
			end
			
		8'H01: 
			begin
				gba_cart_CS <= 1'b1;
				budDir <= 1'b1;
				step <= 8'H02;
			end

		8'H02: 
			begin
				gba_cart_upAdd <= gba_cart_Add[23:16];
				gba_cart_lowAdd <= gba_cart_Add[15:0];
				step <= 8'H03;
			end

		8'H03: 
			begin
				gba_cart_CS <= 1'b0;
				step <= 8'H04;
			end

		8'H04: 
			begin
				budDir <= 1'b0;
				step <= 8'H05;
			end

		8'H05: 
			begin
				gba_cart_RD <= 1'b0;
				step <= 8'H06;
			end

		8'H06: 
			begin
				memDumped[memIdx] = gba_cart_romData[7:0];
				memDumped[memIdx + 1] = gba_cart_romData[15:8];

				
				step <= 8'H07;
			end

		8'H07: 
			begin
				gba_cart_Add <= gba_cart_Add + 1;
					if(newDump == 0) begin
						step <= 8'HA0; //
					end
					else begin
						step <= 8'HA2; //
					end
			end
		// ----------- SEQUENTIAL
		8'H08: 
			begin
				gba_cart_RD <= 1'b1;
				step <= 8'H09;
			end
		8'H09: 
			begin
				gba_cart_RD <= 1'b0;
				step <= 8'H0A;
			end

		8'H0A: 
			begin
				memDumped[memIdx] = gba_cart_romData[7:0];
				memDumped[memIdx + 1] = gba_cart_romData[15:8];

				step <= 8'HA2;
			end


		// ----------- START TRANSMISSION
		8'HA0: begin
			tx_data <= openMsg[memIdxB];
			if(memIdxB <= OPENMSG_SIZE) begin
				memIdxB <= memIdxB + 1;
				step <= 8'HA1;
			end
			else begin
				memIdxB <= 0;
				step <= 8'HB2;
			end
			
			send <= 1;
		end
		8'HA1: begin
			step <= 8'HA0;
			send <= 0;
		end
		// ----------- END TRANSMISSION
		8'HA6: begin
			tx_data <= endMsg[memIdxB];
			send <= 1;
			if(memIdxB <= ENDMSG_SIZE) begin
				memIdxB <= memIdxB + 1;
				step <= 8'HA7;
			end
			else begin
				memIdxB <= 0;
				step <= 8'H00;
			end

		end
		8'HA7: begin
			send <= 0;
			step <= 8'HA6;
		end
		// ------ DEAD TRANSMISSION TO AVOID BUG
		8'HB2: begin
			tx_data <= 8'H00;
			step <= 8'HB3;
			send <= 1;

		end
		8'HB3: begin
			newDump <= 1;
			send <= 0;
			nextStep <= 8'HA2;
			step <= 8'HFF;
		end
		// ------ INFO TRANSMISSION A
		8'HA2: begin
			tx_data <= memDumped[0];
			step <= 8'HA3;
			send <= 1;

		end
		8'HA3: begin
			newDump <= 1;
			send <= 0;
			nextStep <= 8'HA4;
			step <= 8'HFF;
			nDumps <= nDumps + 1;
		end
		// ------ INFO TRANSMISSION B
		8'HA4: begin
			tx_data <= memDumped[1];
			send <= 1;
			step <= 8'HA5;
		end
		8'HA5: begin
			newDump <= 1;
			send <= 0;
			nextStep <= 8'H08; // TO SEQUENTIAL ACCESS
			step <= 8'HFF;
			nDumps <= nDumps + 1;
		end

		// ------ IDLE
		8'HFF: begin
			step <= nextStep;
		end


	endcase
end

endmodule
